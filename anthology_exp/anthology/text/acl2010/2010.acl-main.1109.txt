    A Tree Transducer Model for Synchronous Tree-Adjoining Grammars

                                          Andreas Maletti
                                     Universitat Rovira i Virgili
                          Avinguda de Catalunya 25, 43002 Tarragona, Spain.
                                 andreas.maletti@urv.cat



                      Abstract                                tion phenomena. Instead Shieber (2007) suggests
    A characterization of the expressive power                a yet more powerful mechanism, synchronous
    of synchronous tree-adjoining grammars                    tree-adjoining grammars (STAGs) as introduced
    (STAGs) in terms of tree transducers (or                  by Shieber and Schabes (1990), that can capture
    equivalently, synchronous tree substitution               certain (mildly) context-sensitive features of natu-
    grammars) is developed. Essentially, a                    ral language. In the tradition of Shieber (2004), a
    STAG corresponds to an extended tree                      characterization of the power of STAGs in terms
    transducer that uses explicit substitution in             of bimorphims was developed by Shieber (2006).
    both the input and output. This characteri-               The bimorphisms used are rather unconventional
    zation allows the easy integration of STAG                because they consist of a regular tree language and
    into toolkits for extended tree transducers.              two embedded tree transducers (instead of two tree
    Moreover, the applicability of the charac-                homomorphisms). Such embedded tree transduc-
    terization to several representational and                ers (Shieber, 2006) are particular macro tree trans-
    algorithmic problems is demonstrated.                     ducers (Courcelle and Franchi-Zannettacci, 1982;
                                                              Engelfriet and Vogler, 1985).
1   Introduction                                                 In this contribution, we try to unify the pic-
Machine translation has seen a multitude of for-              ture even further. We will develop a tree trans-
mal translation models. Here we focus on syntax-              ducer model that can simulate STAGs. It turns out
based (or tree-based) models. One of the old-                 that the adjunction operation of an STAG can be
est models is the synchronous context-free gram-              explained easily by explicit substitution. In this
mar (Aho and Ullman, 1972). It is clearly too                 sense, the slogan that an STAG is an STSG with
weak as a syntax-based model, but found use in                adjunction, which refers to the syntax, also trans-
the string-based setting. Top-down tree transduc-             lates to the semantics. We prove that any tree
ers (Rounds, 1970; Thatcher, 1970) have been                  transformation computed by an STAG can also be
heavily investigated in the formal language com-              computed by an STSG using explicit substitution.
munity (Gécseg and Steinby, 1984; Gécseg and                Thus, a simple evaluation procedure that performs
Steinby, 1997), but as argued by Shieber (2004)               the explicit substitution is all that is needed to sim-
they are still too weak for syntax-based machine              ulate an STAG in a toolkit for STSGs or extended
translation. Instead Shieber (2004) proposes syn-             tree transducers like T IBURON by May and Knight
chronous tree substitution grammars (STSGs) and               (2006).
develops an equivalent bimorphism (Arnold and                    We show that some standard algorithms on
Dauchet, 1982) characterization. This character-              STAG can actually be run on the constructed
ization eventually led to the rediscovery of ex-              STSG, which often is simpler and better under-
tended tree transducers (Graehl and Knight, 2004;             stood. Further, it might be easier to develop new
Knight and Graehl, 2005; Graehl et al., 2008),                algorithms with the alternative characterization,
which are essentially as powerful as STSG. They               which we demonstrate with a product construc-
had been studied already by Arnold and Dauchet                tion for input restriction in the spirit of Neder-
(1982) in the form of bimorphisms, but received               hof (2009). Finally, we also present a complete
little attention until rediscovered.                          tree transducer model that is as powerful as STAG,
    Shieber (2007) claims that even STSGs might               which is an extension of the embedded tree trans-
be too simple to capture naturally occuring transla-          ducers of Shieber (2006).


                                                        1067
       Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1067–1076,
                 Uppsala, Sweden, 11-16 July 2010. c 2010 Association for Computational Linguistics


2    Notation                                                                                                       S
                                                                          S
                                                                                             NP            NP             VP
We quickly recall some central notions about trees,                  NP       VP
tree languages, and tree transformations. For a                                            DT        N   DT     N    V         NP
                                                                          V       NP
more in-depth discussion we refer to Gécseg and                                           the           the        saw      DT     N
                                                                      saw
Steinby (1984) and Gécseg and Steinby (1997). A                                                                             the
finite set Σ of labels is an alphabet. The set of all
                                                                              t                  u                  t[u]NP
strings over that alphabet is Σ∗ where ε denotes
the empty string. To simplify the presentation, we
                                                                                       Figure 1: A substitution.
assume an infinite set X = {x1 , x2 , . . . } of vari-
ables. Those variables are syntactic and represent
only themselves. In particular, they are all differ-              result of) the substitution that replaces all leaves
ent. For each k ≥ 0, we let Xk = {x1 , . . . , xk }.              labeled A in the tree t by the tree u. If t ∈ TΣ (V )
We can also form trees over the alphabet Σ. To                    and u ∈ T∆ (Y ), then t[u]A ∈ TΣ∪∆ (V ∪ Y ). We
allow some more flexibility, we will also allow                   often use the variables of X = {x1 , x2 , . . . } as
leaves from a special set V . Formally, a Σ-tree                  substitution points and write t[u1 , . . . , uk ] instead
over V is either:                                                 of (· · · (t[u1 ]x1 ) . . . )[uk ]xk .
   • a leaf labeled with an element of v ∈ Σ ∪ V ,                   An example substitution is shown in Figure 1.
      or                                                          The figure also illustrates a common problem with
   • a node that is labeled with an element of Σ                  substitution. Occasionally, it is not desirable to re-
      with k ≥ 1 children such that each child is a               place all leaves with a certain label by the same
      Σ-tree over V itself.1                                      tree. In the depicted example, we might want
The set of all Σ-trees over V is denoted by TΣ (V ).              to replace one ‘NP’ by a different tree, which
We just write TΣ for TΣ (∅). The trees in Figure 1                cannot be achieved with substitution. Clearly,
are, for example, elements of T∆ (Y ) where                       this problem is avoided if the source tree t con-
                                                                  tains only one leaf labeled A. We call a tree A-
             ∆ = {S, NP, VP, V, DT, N}                            proper if it contains exactly one leaf with label A.2
             Y = {saw, the} .                                     The subset CΣ (Xk ) ⊆ TΣ (Xk ) contains exactly
                                                                  those trees of TΣ (Xk ) that are xi -proper for every
We often present trees as terms. A leaf labeled v                 1 ≤ i ≤ k. For example, the tree t of Figure 1 is
is simply written as v. The tree with a root node                 ‘saw’-proper, and the tree u of Figure 1 is ‘the’-
labeled σ is written σ(t1 , . . . , tk ) where t1 , . . . , tk    and ‘N’-proper.
are the term representations of its k children.                      In this contribution, we will also use substitu-
   A tree language is any subset of TΣ (V ) for                   tion as an explicit operator. The tree t[u]NP in
some alphabet Σ and set V . Given another al-                     Figure 1 only shows the result of the substitution.
phabet ∆ and a set Y , a tree transformation is a                 It cannot be infered from the tree alone, how it
relation τ ⊆ TΣ (V ) × T∆ (Y ). In many of our                    was obtained (if we do not know t and u).3 To
examples we have V = ∅ = Y . Occasionally,                        make substitution explicit, we use the special bi-
we also speak about the translation of a tree trans-              nary symbols ·[·]A where A is a label. Those sym-
formation τ ⊆ TΣ × T∆ . The translation of τ is                   bols will always be used with exactly two chil-
the relation {(yd(t), yd(u)) | (t, u) ∈ τ } where                 dren (i.e., as binary symbols). Since this prop-
yd(t), the yield of t, is the sequence of leaf labels             erty can easily be checked by all considered de-
in a left-to-right tree traversal of t. The yield of the          vices, we ignore trees that use those symbols in a
third tree in Figure 1 is “the N saw the N”. Note                 non-binary manner. For every set Σ of labels, we
that the translation is a relation τ 0 ⊆ Σ∗ × ∆∗ .                let Σ = Σ ∪ {·[·]A | A ∈ Σ} be the extended
                                                                  set of labels containing also the substition sym-
3    Substitution
                                                                  bols. The substitution of Figure 1 can then be ex-
A standard operation on (labeled) trees is substitu-                  2
                                                                        A-proper trees are sometimes also called A-context in
tion, which replaces leaves with a specified label                the literature.
                                                                      3
in one tree by another tree. We write t[u]A for (the                    This remains true even if we know that the participating
                                                                  trees t and u are A-proper and the substitution t[u]A replac-
   1
     Note that we do not require the symbols to have a fixed      ing leaves labeled A was used. This is due to the fact that, in
rank; i.e., a symbol does not determine its number of children.   general, the root label of u need not coincide with A.


                                                              1068


                                                                          qS                                    qNP
pressed as the tree ·[·]NP (t, u). To obtain t[u]NP
                                                                                               S’                          NP
(the right-most tree in Figure 1), we have to evalu-                      S                                     NP
ate ·[·]NP (t, u). However, we want to replace only                                  → qV     qNP   qNP                   → N
                                                                     x1        VP                            DT       N
one leaf at a time. Consequently, we restrict the                                       x2    x1     x3                    atefl
evaluation of ·[·]A (t, u) such that it applies only to                   x2    x3                           the   boy
trees t whose evaluation is A-proper. To enforce
this restriction, we introduce an error signal ⊥,                 Figure 2: Example rules taken from Graehl et al.
which we assume not to occur in any set of la-                    (2009). The term representation of the first rule
bels. Let Σ be the set of labels. Then we define                  is (qS , S(x1 , VP(x2 , x3 ))) → (w, S0 (x2 , x1 , x3 ))
the function ·E : TΣ → TΣ ∪ {⊥} by4                               where w = qNP qV qNP .
 σ(t1 , . . . , tk )E = σ(tE            E
                           1 , . . . , tk )
                        (                                              where k ≥ 0, l ∈ CΣ (Xk ), and r ∈ C∆ (Xk ).
                          tE [uE ]A if tE is A-proper               Recall that any tree of CΣ (Xk ) contains each
    ·[·]A (t, u)E =
                          ⊥               otherwise               variable of Xk = {x1 , . . . , xk } exactly once. In
                                                                  graphical representations of a rule
for every k ≥ 0, σ ∈ Σ, and t, t1 , . . . , tk , u ∈ TΣ .5
We generally discard all trees that contain the er-                                  (q, l) → (q1 · · · qk , r) ∈ R ,
ror signal ⊥. Since the devices that we will study
                                                                  we usually
later can also check the required A-properness us-
                                                                     • add the state q as root node of the left-hand
ing their state behavior, we generally do not dis-
                                                                        side7 , and
cuss trees with error symbols explicitly.
                                                                     • add the states q1 , . . . , qk on top of the nodes
4       Extended tree transducer                                        labeled x1 , . . . , xk , respectively, in the right-
                                                                        hand side of the rule.
An extended tree transducer is a theoretical model
                                                                  Some example rules are displayed in Figure 2.
that computes a tree transformation. Such trans-
                                                                     The rules are applied in the expected way (as in
ducers have been studied first by Arnold and
                                                                  a term-rewrite system). The only additional fea-
Dauchet (1982) in a purely theoretic setting, but
                                                                  ture are the states of Q, which can be used to con-
were later applied in, for example, machine trans-
                                                                  trol the derivation. A sentential form is a tree that
lation (Knight and Graehl, 2005; Knight, 2007;
                                                                  contains exclusively output symbols towards the
Graehl et al., 2008; Graehl et al., 2009). Their
                                                                  root and remaining parts of the input headed by a
popularity in machine translation is due to Shieber
                                                                  state as leaves. A derivation step starting from ξ
(2004), in which it is shown that extended tree
                                                                  then consists in
transducers are essentially (up to a relabeling) as
                                                                     • selecting a leaf of ξ with remaining input
expressive as synchronous tree substitution gram-
                                                                        symbols,
mars (STSG). We refer to Chiang (2006) for an
                                                                     • matching the state q and the left-hand side l
introduction to synchronous devices.
                                                                        of a rule (q, l) → (q1 · · · qk , r) ∈ R to the
   Let us recall the formal definition. An ex-
                                                                        state and input tree stored in the leaf, thus
tended tree transducer (for short: XTT)6 is a sys-
                                                                        matching input subtrees t1 , . . . , tk to the vari-
tem M = (Q, Σ, ∆, I, R) where
                                                                        ables x1 , . . . , xk ,
   • Q is a finite set of states,
                                                                     • replacing all the variables x1 , . . . , xk in the
   • Σ and ∆ are alphabets of input and output
                                                                        right-hand side r by the matched input sub-
     symbols, respectively,
                                                                        trees q1 (t1 ), . . . , qk (tk ) headed by the corre-
   • I ⊆ Q is a set of initial states, and
                                                                        sponding state, respectively, and
   • R is a finite set of rules of the form
                                                                     • replacing the selected leaf in ξ by the tree
                     (q, l) → (q1 · · · qk , r)                         constructed in the previous item.
    4
      Formally, we should introduce an evaluation function for
                                                                  The process is illustrated in Figure 3.
each alphabet Σ, but we assume that the alphabet can be in-          Formally, a sentential form of the XTT M is a
fered.                                                            tree of SF = T∆ (Q(TΣ )) where
    5
      This evaluation is a special case of a yield-mapping (En-
gelfriet and Vogler, 1985).                                                     Q(TΣ ) = {q(t) | q ∈ Q, t ∈ TΣ } .
    6
      Using the notions of Graehl et al. (2009) our extended
                                                                     7
tree transducers are linear, nondeleting extended top-down             States are thus also special symbols that are exclusively
tree transducers.                                                 used as unary symbols.


                                                              1069


                                                                                                           NP
                                                                 NP                     N
           C                                                                                         DT            N
                                                        DT            N            N?       ADJ
           qS                       C                                                                les   N           ADJ
                                                           les     bonbons               rouges
                                                                                                         bonbons       rouges
           S              ⇒         S’
                              qV   qNP     qNP                   derived           auxiliary               adjunction
                VP                                                 tree              tree
      t1
                              t2    t1      t3          Figure 4: Illustration of an adjunction taken from
           t2        t3                                 Nesson et al. (2008).
                                                                                    NP
Figure 3: Illustration of a derivation step of an
XTT using the left rule of Figure 2.                                       DT               ·[·]N?

                                                                             les    N                N
Given ξ, ζ ∈ SF, we write ξ ⇒ ζ if there ex-
ist C ∈ C∆ (X1 ), t1 , . . . , tk ∈ TΣ , and a rule                           N?        ADJ       bonbons
(q, l) → (q1 · · · qk , r) ∈ R such that                                                rouges
   • ξ = C[q(l[t1 , . . . , tk ])] and
   • ζ = C[r[q1 (t1 ), . . . , qk (tk )]].              Figure 5: Illustration of the adjunction of Figure 4
The tree transformation computed by M is the re-        using explicit substitution.
lation
                                                        Steinby, 1997) enhanced with an adjunction oper-
 τM = {(t, u) ∈ TΣ × T∆ | ∃q ∈ I : q(t) ⇒∗ u}           ation. Roughly speaking, an adjunction replaces a
                                                        node (not necessarily a leaf) by an auxiliary tree,
where ⇒∗ is the reflexive, transitive closure of ⇒.     which has exactly one distinguished foot node.
In other words, the tree t can be transformed into u    The original children of the replaced node will be-
if there exists an initial state q such that we can     come the children of the foot node after adjunc-
derive u from q(t) in several derivation steps.         tion. Traditionally, the root label and the label of
   We refer to Arnold and Dauchet (1982), Graehl        the foot node coincide in an auxiliary tree aside
et al. (2008), and Graehl et al. (2009) for a more      from a star index that marks the foot node. For
detailed exposition to XTT.                             example, if the root node of an auxiliary tree is
                                                        labeled A, then the foot node is traditionally la-
5   Synchronous tree-adjoining grammar                  beled A? . The star index is not reproduced once
XTT are a simple, natural model for tree trans-         adjoined. Formally, the adjunction of the auxil-
formations, however they are not suitably ex-           iary tree u with root label A (and foot node la-
pressive for all applications in machine transla-       bel A? ) into a tree t = C[A(t1 , . . . , tk )] with
tion (Shieber, 2007). In particular, all tree trans-    C ∈ CΣ (X1 ) and t1 , . . . , tk ∈ TΣ is
formations of XTT have a certain locality condi-                           C[u[A(t1 , . . . , tk )]A? ] .
tion, which yields that the input tree and its corre-
sponding translation cannot be separated by an un-      Adjunction is illustrated in Figure 4.
bounded distance. To overcome this problem and             We note that adjunction can easily be expressed
certain dependency problems, Shieber and Sch-           using explicit substitution. Essentially, only an ad-
abes (1990) and Shieber (2007) suggest a stronger       ditional node with the adjoined subtree is added.
model called synchronous tree-adjoining gram-           The result of the adjunction of Figure 4 using ex-
mar (STAG), which in addition to the substitution       plicit substitution is displayed in Figure 5.
operation of STSG (Chiang, 2005) also has an ad-           To simplify the development, we will make
joining operation.                                      some assumptions on all tree-adjoining grammars
   Let us recall the model in some detail. A tree-      (and synchronous tree-adjoining grammars). A
adjoining grammar essentially is a regular tree         tree-adjoining grammar (TAG) is a finite set of
grammar (Gécseg and Steinby, 1984; Gécseg and         initial trees and a finite set of auxiliary trees. Our


                                                    1070


       S           S               S                               S1         S1             S                  S
                                                   S
       T       a       S       b       S                            T     —    T            S1        —     a        S1
                                                   S?
       c         S?        a     S?        b                        c          c        a   S?    a             S?        a

  initial     auxiliary        auxiliary       auxiliary                                     S                  S
   tree         tree             tree            tree               S          S
                                                                          —                 S1        —    b        S1
Figure 6: A TAG for the copy string language                        S?         S?
                                                                                        b   S?    b             S?        b
{wcw | w ∈ {a, b}∗ } taken from Shieber (2006).
                                                                Figure 7: STAG that computes the translation
TAG do not use substitution, but only adjunction.               {(wcwR , wcw) | w ∈ {a, b}∗ } where wR is the
A derivation is a chain of trees that starts with an            reverse of w.
initial tree and each derived tree is obtained from
the previous one in the chain by adjunction of an               STAG G we write τG for the tree transformation
auxiliary tree. As in Shieber (2006) we assume                  computed by G.
that all adjunctions are mandatory; i.e., if an aux-
iliary tree can be adjoined, then we need to make               6       Main result
an adjunction. Thus, a derivation starting from an
initial tree to a derived tree is complete if no ad-            In this section, we will present our main result. Es-
junction is possible in the derived tree. Moreover,             sentially, it states that a STAG is as powerful as a
we assume that to each node only one adjunction                 STSG using explicit substitution. Thus, for every
can be applied. This is easily achieved by label-               tree transformation computed by a STAG, there is
ing the root of each adjoined auxiliary tree by a               an extended tree transducer that computes a repre-
special marker. Traditionally, the root label A of              sentation of the tree transformation using explicit
an auxiliary tree is replaced by A∅ once adjoined.              substitution. The converse is also true. For every
Since we assume that there are no auxiliary trees               extended tree transducer M that uses explicit sub-
with such a root label, no further adjunction is pos-           stitution, we can construct a STAG that computes
sible at such nodes. Another effect of this restric-            the tree transformation represented by τM up to
tion is that the number of operable nodes (i.e., the            a relabeling (a mapping that consistently replaces
nodes to which an adjunction must still be applied)             node labels throughout the tree). The additional
is known at any given time.8 A full TAG with our                relabeling is required because STAGs do not have
restrictions is shown in Figure 6.                              states. If we replace the extended tree transducer
   Intuitively, a synchronous tree-adjoining gram-              by a STSG, then the result holds even without the
mar (STAG) is essentially a pair of TAGs. The                   relabeling.
synchronization is achieved by pairing the initial              Theorem 1 For every STAG G, there exists an ex-
trees and the auxiliary trees. In addition, for each            tended tree transducer M such that
such pair (t, u) of trees, there exists a bijection be-
tween the operable nodes of t and u. Such nodes in                         τG = {(tE , uE ) | (t, u) ∈ τM } .
bijection are linked and the links are preserved in
derivations, in which we now use pairs of trees as              Conversely, for every extended tree transducer M ,
sentential forms. In graphical representations we               there exists a STAG G such that the above relation
often indicate this bijection with integers; i.e., two          holds up to a relabeling.
nodes marked with the same integer are linked. A
pair of auxiliary trees is then adjoined to linked              6.1      Proof sketch
nodes (one in each tree of the sentential form) in              The following proof sketch is intended for readers
the expected manner. We will avoid a formal def-                that are familiar with the literature on embedded
inition here, but rather present an example STAG                tree transducers, macro tree transducers, and bi-
and a derivation with it in Figures 7 and 8. For a              morphisms. It can safely be skipped because we
   8
                                                                will illustrate the relevant construction on our ex-
    Without the given restrictions, this number cannot be de-
termined easily because no or several adjunctions can take      ample after the proof sketch, which contains the
place at a certain node.                                        outline for the correctness.


                                                            1071


                                                                                                    S             S
                                                        S               S                           S         a        S
                       S             S                  S           a       S                       S             b        S

S1     S1             S1         a       S1           S1                b        S1                 S1                 a       S1
T — T             a    S   a—        S        a   b     S    b —            S         b        a    S    a—                S        a
 c      c              T             T            a     S    a          S        a             b    S    b             S       b
                       c             c                  T               T                      a    S    a        S        a
                                                        c               c                           T             T
                                                                                                    c              c

                      Figure 8: An incomplete derivation using the STAG of Figure 7.


   Let τ ⊆ TΣ × T∆ be a tree transformation
computed by a STAG. By Shieber (2006) there                          e1                                            e2
exists a regular tree language L ⊆ TΓ and two                                             h1        h2
functions e1 : TΓ → TΣ and e2 : TΓ → T∆ such
                                                                                               τM
that τ = {(e1 (t), e2 (t)) | t ∈ L}. Moreover,
e1 and e2 can be computed by embedded tree                                  ·E                                ·E
transducers (Shieber, 2006), which are particu-
lar 1-state, deterministic, total, 1-parameter, lin-                                           τ
ear, and nondeleting macro tree transducers (Cour-
celle and Franchi-Zannettacci, 1982; Engelfriet                   Figure 9: Illustration of the proof sketch.
and Vogler, 1985). In fact, the converse is also true
up to a relabeling, which is also shown in Shieber          by an extended tree transducer M due to results
(2006). The outer part of Figure 9 illustrates these        of Shieber (2004) and Maletti (2008). More pre-
relations. Finally, we remark that all involved con-        cisely, every extended tree transducer computes
structions are effective.                                   such a set, so that also this step is a characteri-
   Using a result of Engelfriet and Vogler (1985),          zation. Thus we obtain that τ is an evaluation of a
each embedded tree transducer can be decom-                 tree transformation computed by an extended tree
posed into a top-down tree transducer (Gécseg              transducer, and moreover, for each extended tree
and Steinby, 1984; Gécseg and Steinby, 1997)               transducer, the evaluation can be computed (up to
and a yield-mapping. In our particular case, the            a relabeling) by a STAG. The overall proof struc-
top-down tree transducers are linear and nondelet-          ture is illustrated in Figure 9.
ing homomorphisms h1 and h2 . Linearity and
nondeletion are inherited from the corresponding            6.2    Example
properties of the macro tree transducer. The prop-          Let us illustrate one direction (the construction
erties ‘1-state’, ‘deterministic’, and ‘total’ of the       of the extended tree transducer) on our example
macro tree transducer ensure that the obtained top-         STAG of Figure 7. Essentially, we just prepare all
down tree transducer is also 1-state, determinis-           operable nodes by inserting an explicit substitu-
tic, and total, which means that it is a homomor-           tion just on top of them. The first subtree of that
phism. Finally, the 1-parameter property yields             substitution will either be a variable (in the left-
that the used substitution symbols are binary (as           hand side of a rule) or a variable headed by a state
our substitution symbols ·[·]A ). Consequently, the         (in the right-hand side of a rule). The numbers of
yield-mapping actually coincides with our evalua-           the variables encode the links of the STAG. Two
tion. Again, this decomposition actually is a char-         example rules obtained from the STAG of Figure 7
acterization of embedded tree transducers. Now              are presented in Figure 10. Using all XTT rules
the set {(h1 (t), h2 (t)) | t ∈ L} can be computed          constructed for the STAG of Figure 7, we present


                                                      1072


     qS                        qS
                                                      S
                                                                              STAG to STSG (or vice versa) with the help of
                 ·[·]S?
    ·[·]S?                     S                                              our characterization. However, many standard al-
                qS    S                          a        ·[·]S?              gorithms for STAG can easily be derived from
x1        S →              ·[·]S?            →
                                                     qS                       the corresponding algorithms for STSG. The sim-
                x1    T                                            S
          T               x1        S                                         plest example is the union of two STAG. Instead
                      c                              x1      S?        a      of taking the union of two STAG using the clas-
          c                a        S?   a
                                                                              sical construction, we can take the union of the
                                                                              corresponding XTT (or STSG) that simulate the
          Figure 10: Two constructed XTT rules.
                                                                              STAGs. Their union will simulate the union of the
                                                                              STAGs. Such properties are especially valuable
a complete derivation of the XTT in Figure 11 that                            when we simulate STAG in toolkits for XTT.
(up to the final step) matches the derivation of the                             A second standard algorithm that easily trans-
STAG in Figure 8. The matching is achieved by                                 lates is the algorithm computing the n-best deriva-
the evaluation ·E introduced in Section 3 (i.e., ap-                          tions (Huang and Chiang, 2005). Clearly, the n-
plying the evaluation to the derived trees of Fig-                            best derivation algorithm does not consider a par-
ure 11 yields the corresponding derived trees of                              ticular input or output tree. Since the derivations
Figure 8.                                                                     of the XTT match the derivations of the STAG
                                                                              (in the former the input and output are encoded
7      Applications
                                                                              using explicit substitution), the n-best derivations
In this section, we will discuss a few applications                           will coincide. If we are additionally interested in
of our main result. Those range from representa-                              the input and output trees for those n-best deriva-
tional issues to algorithmic problems. Finally, we                            tions, then we can simply evaluate the coded input
also present a tree transducer model that includes                            and output trees returned by n-best derivation al-
explicit substitution. Such a model might help to                             gorithm.
address algorithmic problems because derivation                                  Finally, let us consider an algorithm that can be
and evaluation are intertwined in the model and                               obtained for STAG by developing it for XTT us-
not separate as in our main result.                                           ing explicit substitution. We will develop a BAR -
                                                                              H ILLEL (Bar-Hillel et al., 1964) construction for
7.1       Toolkits                                                            STAG. Thus, given a STAG G and a recognizable
Obviously, our characterization can be applied in                             tree language L, we want to construct a STAG G0
a toolkit for extended tree transducers (or STSG)                             such that
such as T IBURON by May and Knight (2006) to
                                                                                     τG0 = {(t, u) | (t, u) ∈ τG , t ∈ L} .
simulate STAG. The existing infrastructure (input-
output, derivation mechanism, etc) for extended                               In other words, we take the tree transformation τG
tree transducers can be re-used to run XTTs en-                               but additionally require the input tree to be in L.
coding STAGs. The only additional overhead is                                 Consequently, this operation is also called input
the implementation of the evaluation, which is a                              restriction. Since STAG are symmetric, the corre-
straightforward recursive function (as defined in                             sponding output restriction can be obtained in the
Section 3). After that any STAG can be simulated                              same manner. Note that a classical BAR -H ILLEL
in the existing framework, which allows experi-                               construction restricting to a regular set of yields
ments with STAG and an evaluation of their ex-                                can be obtained easily as a particular input restric-
pressive power without the need to develop a new                              tion. As in Nederhof (2009) a change of model
toolkit. It should be remarked that some essential                            is beneficial for the development of such an algo-
algorithms that are very sensitive to the input and                           rithm, so we will develop an input restriction for
output behavior (such as parsing) cannot be sim-                              XTT using explicit substitution.
ulated by the corresponding algorithms for STSG.                                 Let M = (Q, Σ, ∆, I, R) be an XTT (using ex-
It remains an open problem whether the close rela-                            plicit substitution) and G = (N, Σ, I 0 , P ) be a
tionship can also be exploited for such algorithms.                           tree substitution grammar (regular tree grammar)
                                                                              in normal form that recognizes L (i.e., L(G) = L).
7.2       Algorithms                                                          Let S = {A ∈ Σ | ·[·]A ∈ Σ}. A context is a map-
We already mentioned in the previous section                                  ping c : S → N , which remembers a nontermi-
that some algorithms do not easily translate from                             nal of G for each substitution point. Given a rule


                                                                           1073


                                qS                                         ·[·]S?                                      ·[·]S?                                       ·[·]S?                                             ·[·]S?
                                                                                                                                                                                                                                                                       ·[·]S?
                               ·[·]S?                                   qS      S                               S                    S                       S                       S                      S                        S
                                                                                                                                                                                                                                                            S                        S
                         S              S                                S      T                          a        ·[·]S?           T                 a      ·[·]S?                 T                  a      ·[·]S?                T
                                                                                                                                                                                                                                                        a      ·[·]S?                T
                       ·[·]S?           T                              ·[·]S?       c                          qS            S       c                S                      S       c                  S                    S       c
                                                                                                                                                                                                                                                        S                    S       c
                S                S      c                       S               S                               S      S?        a                b        ·[·]S?       S?       a                b      ·[·]S?         S?       a
                                            ⇒                                               ⇒                                            ⇒                                               ⇒                                               ⇒        b      ·[·]S?         S?       a
              ·[·]S?       a     S?     a                     ·[·]S?       a    S?      a                     ·[·]S?                                  qS            S                            S                      S
                                                                                                                                                                                                                                                  S                     S
       S                S                              S                S                              S                S                             S       S?        b                    a        ·[·]S?       S?       b
                                                                                                                                                                                                                                             a        ·[·]S?       S?       b
     ·[·]S?      b      S?       b                   ·[·]S?      b      S?      b                    ·[·]S?      b     S?        b                ·[·]S?                                         qS            S
                                                                                                                                                                                                                                                 S             S
 S             S                                S              S                                S              S                             S                S                                  S       S?        a
                                                                                                                                                                                                                                                 S?      S?        a
S?     a      S?       a                        S?     a      S?       a                        S?     a      S?       a                     S?       a      S?         a                        S?


                                                Figure 11: Complete derivation using the constructed XTT rules.


(q, l) → (q1 · · · qk , r) ∈ R, a nonterminal p ∈ N ,                                                                                    substitution M = (Q, Σ, ∆, I, R) is simply an
and a context c ∈ S, we construct new rules cor-                                                                                         embedded tree transducer with extended left-hand
responding to successful parses of l subject to the                                                                                      sides (i.e., any number of input symbols is allowed
following restrictions:                                                                                                                  in the left-hand side) that uses the special sym-
   • If l = ·[·]A (l1 , l2 ) for some A ∈ Σ, then se-                                                                                    bols ·[·]A in the input. Formally, let
      lect p0 ∈ N , parse l1 in p with context c0                                                                                           • Q = Q0 ∪ Q1 be finite where Q0 and Q1
      where c0 = c[A 7→ p0 ]9 , and parse l2 in p0                                                                                            are the set of states that do not and do have a
      with context c.                                                                                                                         context parameter, respectively,
   • If l = A? with A ∈ Σ, then p = c(A).                                                                                                   • Σ and ∆ be ranked alphabets such that if
   • Finally, if l = σ(l1 , . . . , lk ) for some σ ∈ Σ,                                                                                      ·[·]A ∈ Σ, then A, A? ∈ Σ,
      then select p → σ(p1 , . . . , pk ) ∈ P is a pro-                                                                                     • QhU i be such that
      duction of G and we parse li with nontermi-                                                                                                                   QhU i = {qhui | q ∈ Q1 , u ∈ U } ∪
      nal pi and context c for each 1 ≤ i ≤ k.
                                                                                                                                                                                                 ∪ {qhi | q ∈ Q0 } ,
7.3        A complete tree transducer model                                                                                                   • I ⊆ QhT∆ i, and
So far, we have specified a tree transducer model                                                                                             • R is a finite set of rules l → r such that there
that requires some additional parsing before it can                                                                                             exists k ≥ 0 with l ∈ Qh{y}i(CΣ (Xk )) and
be applied. This parsing step has to annotate (and                                                                                              r ∈ Rhsk where
correspondingly restructure) the input tree by the                                                                                                                      Rhsk := δ(Rhsk , . . . , Rhsk ) |
adjunction points. This is best illustrated by the                                                                                                                                                    | q1 hRhsk i(x) | q0 hi(x)
left tree in the last pair of trees in Figure 8. To run
our constructed XTT on the trivially completed                                                                                                 with δ ∈ ∆k , q1 ∈ Q1 , q0 ∈ Q0 , and x ∈ Xk .
version of this input tree, it has to be transformed                                                                                           Moreover, each variable of l (including y) is
into the first tree of Figure 11, where the adjunc-                                                                                            supposed to occur exactly once in r.
tions are now visible. In fact, a second un-parsing                                                                                      We refer to Shieber (2006) for a full description
step is required to evaluate the output.                                                                                                 of embedded tree transducers. As seen from the
   To avoid the first additional parsing step, we                                                                                        syntax, we write the context parameter y of a
will now modify our tree transducer model such                                                                                           state q ∈ Q1 as qhyi. If q ∈ Q0 , then we also
that this parsing step is part of its semantics. This                                                                                    write qhi or qhεi. In each right-hand side, such
shows that it can also be done locally (instead of                                                                                       a context parameter u can contain output symbols
globally parsing the whole input tree). In addition,                                                                                     and further calls to input subtrees. The semantics
we arrive at a tree transducer model that exactly                                                                                        of extended embedded tree transducers with sub-
(up to a relabeling) matches the power of STAG,                                                                                          stitution deviates slightly from the embedded tree
which can be useful for certain constructions. It is                                                                                     transducer semantics. Roughly speaking, not its
known that an embedded tree transducer (Shieber,                                                                                         rules as such, but rather their evaluation are now
2006) can handle the mentioned un-parsing step.                                                                                          applied in a term-rewrite fashion. Let
   An extended embedded tree transducer with                                                                                                                            SF0 := δ(SF0 , . . . , SF0 ) |
     9 0
      c is the same as c except that it maps A to p0 .                                                                                                                                       | q1 hSF0 i(t) | q0 hi(t)


                                                                                                                             1074


           qS hi                        qS hi                  BAR -H ILLEL construction for STAG. Finally, we
                          qh·i                      qh·i       hope that the alternative characterization is easier
           ·[·]S?                        S                     to handle and might provide further insight into
                        S     x1                S      S
         x1         →                    S ⇒
                                                               general properties of STAG such as compositions
                S
                        T                       T      S?      and preservation of regularity.
                T                        T
                        c                       c              Acknowledgements
                c                        c
                                                               A NDREAS M ALETTI was financially supported
Figure 12: Rule and derivation step using the rule             by the Ministerio de Educación y Ciencia (MEC)
in an extended embedded tree transducer with sub-              grant JDCI-2007-760.
stitution where the context parameter (if present)
is displayed as first child.
                                                               References
where δ ∈ ∆k , q1 ∈ Q1 , q0 ∈ Q0 , and t ∈ TΣ .                Alfred V. Aho and Jeffrey D. Ullman. 1972. The The-
   Given ξ, ζ ∈ SF0 , we write ξ ⇒ ζ if there exist              ory of Parsing, Translation, and Compiling. Pren-
                                                                 tice Hall.
C ∈ C∆ (X1 ), t1 , . . . , tk ∈ TΣ , u ∈ T∆ ∪ {ε}, and
a rule qhui(l) → r ∈ R10 with l ∈ CΣ (Xk ) such                André Arnold and Max Dauchet. 1982. Morphismes
that                                                             et bimorphismes d’arbres. Theoret. Comput. Sci.,
   • ξ = C[qhui(l[t1 , . . . , tk ]E )] and                      20(1):33–93.
   • ζ = C[(r[t1 , . . . , tk ])[u]y ].
                                                               Yehoshua Bar-Hillel, Micha Perles, and Eliyahu
Note that the essential difference to the “stan-                 Shamir. 1964. On formal properties of simple
dard” semantics of embedded tree transducers is                  phrase structure grammars. In Yehoshua Bar-Hillel,
the evaluation in the first item. The tree transfor-             editor, Language and Information: Selected Essays
mation computed by M is defined as usual. We                     on their Theory and Application, chapter 9, pages
                                                                 116–150. Addison Wesley.
illustrate a derivation step in Figure 12, where the
match ·[·]S? (x1 , S(T (c)))E = S(S(T (c))) is suc-            David Chiang. 2005. A hierarchical phrase-based
cessful for x1 = S(S? ).                                         model for statistical machine translation. In Proc.
                                                                 ACL, pages 263–270. Association for Computa-
Theorem 2 Every STAG can be simulated by an                      tional Linguistics.
extended embedded tree transducer with substi-
tution. Moreover, every extended embedded tree                 David Chiang. 2006. An introduction to synchronous
                                                                 grammars. In Proc. ACL. Association for Computa-
transducer computes a tree transformation that                   tional Linguistics. Part of a tutorial given with Kevin
can be computed by a STAG up to a relabeling.                    Knight.

8        Conclusions                                           Bruno Courcelle and Paul Franchi-Zannettacci. 1982.
                                                                 Attribute grammars and recursive program schemes.
We presented an alternative view on STAG us-                     Theoret. Comput. Sci., 17:163–191, 235–257.
ing tree transducers (or equivalently, STSG). Our
main result shows that the syntactic characteri-               Joost Engelfriet and Heiko Vogler. 1985. Macro tree
                                                                 transducers. J. Comput. System Sci., 31(1):71–146.
zation of STAG as STSG plus adjunction rules
also carries over to the semantic side. A STAG                 Ferenc Gécseg and Magnus Steinby. 1984. Tree Au-
tree transformation can also be computed by an                   tomata. Akadémiai Kiadó, Budapest.
STSG using explicit substitution. In the light
                                                               Ferenc Gécseg and Magnus Steinby. 1997. Tree lan-
of this result, some standard problems for STAG                  guages. In Handbook of Formal Languages, vol-
can be reduced to the corresponding problems                     ume 3, chapter 1, pages 1–68. Springer.
for STSG. This allows us to re-use existing algo-
rithms for STSG also for STAG. Moreover, exist-                Jonathan Graehl and Kevin Knight. 2004. Training
                                                                 tree transducers. In HLT-NAACL, pages 105–112.
ing STAG algorithms can be related to the corre-                 Association for Computational Linguistics. See
sponding STSG algorithms, which provides fur-                    also (Graehl et al., 2008).
ther evidence of the close relationship between the
two models. We used this relationship to develop a             Jonathan Graehl, Kevin Knight, and Jonathan May.
                                                                 2008. Training tree transducers. Computational
    10
         Note that u is ε if q ∈ Q0 .                            Linguistics, 34(3):391–427.


                                                            1075


Jonathan Graehl, Mark Hopkins, Kevin Knight, and
  Andreas Maletti. 2009. The power of extended top-
  down tree transducers. SIAM Journal on Comput-
  ing, 39(2):410–430.
Liang Huang and David Chiang. 2005. Better k-best
  parsing. In Proc. IWPT, pages 53–64. Association
  for Computational Linguistics.
Kevin Knight and Jonathan Graehl. 2005. An over-
  view of probabilistic tree transducers for natural lan-
  guage processing. In Proc. CICLing, volume 3406
  of LNCS, pages 1–24. Springer.
Kevin Knight. 2007. Capturing practical natural
  language transformations. Machine Translation,
  21(2):121–133.
Andreas Maletti. 2008. Compositions of extended top-
  down tree transducers. Inform. and Comput., 206(9–
  10):1187–1196.
Jonathan May and Kevin Knight. 2006. T IBURON:
  A weighted tree automata toolkit. In Proc. CIAA,
  volume 4094 of LNCS, pages 102–113. Springer.
Mark-Jan Nederhof. 2009. Weighted parsing of trees.
 In Proc. IWPT, pages 13–24. Association for Com-
 putational Linguistics.

Rebecca Nesson, Giorgio Satta, and Stuart M. Shieber.
  2008. Optimal k-arization of synchronous tree-
  adjoining grammar. In Proc. ACL, pages 604–612.
  Association for Computational Linguistics.

William C. Rounds. 1970. Mappings and grammars
  on trees. Math. Systems Theory, 4(3):257–287.

Stuart M. Shieber and Yves Schabes. 1990. Syn-
   chronous tree-adjoining grammars. In Proc. Com-
   putational Linguistics, volume 3, pages 253–258.
Stuart M. Shieber. 2004. Synchronous grammars as
   tree transducers. In Proc. TAG+7, pages 88–95.
Stuart M. Shieber. 2006. Unifying synchronous tree
   adjoining grammars and tree transducers via bimor-
   phisms. In Proc. EACL, pages 377–384. Association
   for Computational Linguistics.
Stuart M. Shieber. 2007. Probabilistic synchronous
   tree-adjoining grammars for machine translation:
   The argument from bilingual dictionaries. In Proc.
   Workshop on Syntax and Structure in Statistical
   Translation, pages 88–95. Association for Compu-
   tational Linguistics.
James W. Thatcher. 1970. Generalized2 sequential
  machine maps. J. Comput. System Sci., 4(4):339–
  367.




                                                        1076
